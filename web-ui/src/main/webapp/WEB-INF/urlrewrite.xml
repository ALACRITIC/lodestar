<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE urlrewrite PUBLIC "-//tuckey.org//DTD UrlRewrite 2.6//EN"
        "http://tuckey.org/res/dtds/urlrewrite2.6.dtd">

<!--

    Configuration file for UrlRewriteFilter
    http://tuckey.org/urlrewrite/

-->
<urlrewrite>

    <!--
      Note:  "from" patterns, by default, match anywhere in the URL.  So, for example, if you write
        <from>/sparql</from>
      then that would match "/scripts/sparql.js".
      So, in general, always anchor your "from" patterns with "^/" and "$".
    -->


    <!-- Testing -->
    <rule>
      <from>^/foo$</from>
      <to>/error2.html</to>
    </rule>


    <rule>
        <condition name="Accept" type="header">text/html</condition>
        <from>^/sparql$</from>
        <to>/query.html</to>
    </rule>

    <rule>
        <condition name="Accept" type="header" operator="notequal">text/html</condition>
        <from>^/sparql(.*)$</from>
        <to>/servlet/query$1</to>
    </rule>

    <rule>
      <condition name="Accept" type="header">text/html</condition>
      <from>^/((D|Q|T|M)[^.]*)$</from>
      <to type="redirect" qsappend="false">$1.html</to>
    </rule>

    <rule>
      <from>^/(D|Q|T|M).*\.html$</from>
      <to>/explore.html</to>
    </rule>


    <!--
      FIXME:  the following sets should probably be combined into just two rules, the
      first that matchies a URI with not dot and an accept header not equal to "text/html";
      and the second that matches any URI with a dot.
      Note that there's a lot of redundant places where content-types are mapped to 
      extensions - both here and in ExporeServlet.java.  Could be DRY'ed.
      But for now, we'll be explicit here about what accept headers and format extensions
      we'll allow.
    -->

    <rule>
      <condition name="Accept" type="header">application/rdf\+xml</condition>
      <from>^/((D|Q|T|M)[^.]*)$</from>
      <to>/servlet/explore?id=$1&amp;format=rdf</to>
    </rule>

    <rule>
      <from>^/((D|Q|T|M).*)\.rdf$</from>
      <to>/servlet/explore?id=$1&amp;format=rdf</to>
    </rule>




    <rule>
      <condition name="Accept" type="header">application/rdf\+n3</condition>
      <from>^/((D|Q|T|M)[^.]*)$</from>
      <to>/servlet/explore?id=$1&amp;format=n3</to>
    </rule>

    <rule>
      <from>^/((D|Q|T|M).*)\.n3$</from>
      <to>/servlet/explore?id=$1&amp;format=n3</to>
    </rule>



    <rule>
      <condition name="Accept" type="header">application/rdf\+json</condition>
      <from>^/((D|Q|T|M)[^.]*)$</from>
      <to>/servlet/explore?id=$1&amp;format=json</to>
    </rule>

    <rule>
      <from>^/((D|Q|T|M).*)\.json$</from>
      <to>/servlet/explore?id=$1&amp;format=rdf</to>
      <!--<to>/servlet/explore?id=$1&amp;format=json</to>-->
    </rule>




<!-- done up to here -->


<!--
    <rule>
      <condition type="method" operator='equal'>POST</condition>
      <from>/sparql$</from>
      <to last="true">/servlet/query$1</to>
    </rule>



    <rule>
        <condition name="Accept" type="header" next="or">text/html</condition>
        <condition name="user-agent">MSIE</condition>
        <from>/describe$</from>
        <to>/explore.html</to>
    </rule>
-->


<!--
    <rule>
        <condition name="Accept" type="header">application/sparql.*</condition>
        <from>/sparql(.*)$</from>
        <to>/servlet/query$1</to>
    </rule>

    <rule>
        <condition name="Accept" type="header">text/*</condition>
        <from>/sparql(.*)$</from>
        <to>/servlet/query$1</to>
    </rule>
     -->


  <!-- explore service rewriting 
    <rule>
        <condition name="Accept" type="header" operator="notequal">text/html</condition>
        <from>/describe$</from>
        <to>/servlet/explore$1</to>
    </rule>

    <rule>
        <condition name="Accept" type="header">application/rdf.*</condition>
        <from>/describe(.*)$</from>
        <to>/servlet/explore$1</to>
    </rule>
  -->




    <!-- depict; which right now is a copy/hack of describe/explore -->

    <!--
      The first set of rules does the content-negotiation.  If the user gives us a URL without a
      filename extension, then we will redirect him to the same URL, but with a filename extension
      added.  The extension depends on the value of the "Accept" header.

    <rule>
      <condition name="Accept" type="header">application/rdf+xml</condition>
      <from>/depict/([^.]*)$</from>
      <to type="redirect" qsappend="false">$1.rdf</to>
    </rule>

    <rule>
      <condition name="Accept" type="header">application/json</condition>
      <from>/depict/([^.]*)$</from>
      <to type="redirect" qsappend="false">$1.json</to>
    </rule>
    -->

    <!--
      Now handle the URLs that have extensions.  First, ".html" - it is special, because it's
      handled by the static html page, which then uses JS to make a pretty display.
    <rule>
      <from>/depict/(.*).html</from>
      <to>/depict.html</to>
    </rule>
    -->

    <!--
      Next, any other URL that has an extension will get passed to the depict servlet for 
      processing.
    <rule>
      <from>/depict/(.*)\.(.*)$</from>
      <to>/servlet/explore?id=$1&amp;format=$2</to>
    </rule>
    -->





</urlrewrite>
